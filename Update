-- ðŸ”¥ VOIDWARE ULTIMATE v11.5 | UNIVERSE FOOTBALL | WITH KEY SYSTEM
-- âœ… UNIVERSE COMPATIBLE â€¢ KEY SYSTEM â€¢ INSTANT TELEPORT â€¢ FULL FTCHUB FEATURES

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- ðŸ”¥ KEY SYSTEM CONFIGURATION
local KEY_SYSTEM = {
    Enabled = true,
    ValidationURL = "https://work.ink/_api/v2/token/isValid/",
    GetKeyURL = "https://work.ink/token", -- Users get their key from here
    SavedKeyFile = "VoidwareKey_v11.lua"
}

-- ðŸ”¥ GET USER IP (FOR VALIDATION)
local function GetUserIP()
    local success, result = pcall(function()
        return game:HttpGet("https://api.ipify.org?format=json")
    end)
    if success then
        local data = HttpService:JSONDecode(result)
        return data.ip
    end
    return nil
end

-- ðŸ”¥ VALIDATE KEY
local function ValidateKey(token)
    local success, result = pcall(function()
        return game:HttpGet(KEY_SYSTEM.ValidationURL .. token)
    end)
   
    if not success then
        return false, "Failed to connect to validation server"
    end
   
    local data = HttpService:JSONDecode(result)
   
    if data.valid then
        return true, "Key validated successfully!"
    else
        return false, "Invalid or expired key"
    end
end

-- ðŸ”¥ SAVE KEY LOCALLY
local function SaveKey(key)
    writefile(KEY_SYSTEM.SavedKeyFile, key)
end

-- ðŸ”¥ LOAD SAVED KEY
local function LoadSavedKey()
    if isfile(KEY_SYSTEM.SavedKeyFile) then
        return readfile(KEY_SYSTEM.SavedKeyFile)
    end
    return nil
end

-- ðŸ”¥ KEY SYSTEM UI
local function ShowKeySystem()
    local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
    local KeyWindow = Rayfield:CreateWindow({
        Name = "ðŸ”‘ VOIDWARE v11.5 | KEY SYSTEM",
        LoadingTitle = "Key Validation Required",
        LoadingSubtitle = "Enter your key to continue",
        ConfigurationSaving = {Enabled = false},
        KeySystem = false
    })
   
    local KeyTab = KeyWindow:CreateTab("ðŸ”‘ Enter Key", 4483362458)
   
    KeyTab:CreateSection("Enter Your Key")
    KeyTab:CreateParagraph({
        Title = "Key Required",
        Content = "Enter the key that the developer sent you.\n\nThis is a paid script - check your purchase for the key."
    })
   
    local keyInput = ""
   
    KeyTab:CreateInput({
        Name = "Enter Key",
        PlaceholderText = "Paste your key here...",
        RemoveTextAfterFocusLost = false,
        Callback = function(text)
            keyInput = text
        end
    })
   
    KeyTab:CreateButton({
        Name = "âœ… Validate Key",
        Callback = function()
            if keyInput == "" then
                Rayfield:Notify({
                    Title = "âŒ Error",
                    Content = "Please enter a key first",
                    Duration = 3
                })
                return
            end
           
            Rayfield:Notify({
                Title = "â³ Validating...",
                Content = "Please wait...",
                Duration = 2
            })
           
            wait(0.5)
           
            local valid, message = ValidateKey(keyInput)
           
            if valid then
                SaveKey(keyInput)
                Rayfield:Notify({
                    Title = "âœ… Success!",
                    Content = message,
                    Duration = 3
                })
                wait(1)
                Rayfield:Destroy()
                LoadMainScript()
            else
                Rayfield:Notify({
                    Title = "âŒ Invalid Key",
                    Content = message,
                    Duration = 5
                })
            end
        end
    })
end

-- ðŸ”¥ MAIN SCRIPT (RUNS AFTER KEY VALIDATION)
function LoadMainScript()
    -- ðŸ”¥ UNIVERSE SAFE FPS BOOST
    pcall(function()
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 9e9
        Lighting.Brightness = 2
    end)

    -- ðŸ”¥ RAYFIELD UI
    local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

    local Window = Rayfield:CreateWindow({
        Name = "VOIDWARE v11.5 | Premium Hub",
        Icon = "crown",
        LoadingTitle = "VOIDWARE Loading",
        LoadingSubtitle = "by VOIDWARE",
        ShowText = "VOIDWARE",
        Theme = "Dark",
        ToggleUIKeybind = "K",
        DisableRayfieldPrompts = false,
        DisableBuildWarnings = false,
        ConfigurationSaving = {
            Enabled = true,
            FolderName = nil,
            FileName = "VOIDWARE"
        },
        Discord = {
            Enabled = true,
            Invite = "CaBXG2jms3",
            RememberJoins = true
        },
        KeySystem = false
    })

    Rayfield:Notify({
        Title = "VOIDWARE v11.5",
        Content = "Welcome to VOIDWARE! Press K to toggle UI.",
        Duration = 6.5,
        Image = "check-circle"
    })

    -- Services
    local Players = game:GetService("Players")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    local TweenService = game:GetService("TweenService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera

    -- Config
    local cfg = {
        pullEnabled = false,
        pullDistance = 50,
        offsetDistance = 3,
        pullSpeed = 100,
        walkspeedMultiplier = 1,
        walkspeedBase = 16,
        flyEnabled = false,
        flySpeed = 50,
        qbAimbotEnabled = false,
        qbPredictionTime = 0.13,
        qbMaxDistance = 150,
        qbShowESP = true,
        qbAutoThrow = false,
        qbTeamCheck = true,
        ballTeleportKey = Enum.KeyCode.B,
        jumpPowerEnabled = false,
        jumpPower = 0,
        infiniteStamina = false,
        bigheadEnabled = false,
        bigheadSize = 1,
        bigheadTransparency = 0,
        bigheadCanCollide = false,
        tackleReachEnabled = false,
        tackleReachDistance = 1,
        autoFollowBallCarrier = false,
        followDistance = 5,
        followSpeed = 150,
    }

    -- PullVector M1 Hold System
    local pulling = false
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            pulling = true
        end
    end)
    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            pulling = false
        end
    end)

    -- Ball Finding Logic
    local ballPart = nil
    local function findBall()
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                local name = obj.Name:lower()
                if name:find("ball") or name:find("football") then
                    if not obj.Anchored and obj.CanCollide then
                        ballPart = obj
                        return ballPart
                    end
                end
            end
        end
       
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj:IsA("Model") then
                local name = obj.Name:lower()
                if name:find("ball") or name:find("football") then
                    local part = obj.PrimaryPart or obj:FindFirstChild("Handle") or obj:FindFirstChildWhichIsA("BasePart")
                    if part and not part.Anchored then
                        ballPart = part
                        return ballPart
                    end
                end
            end
        end
       
        return nil
    end
    task.spawn(function()
        wait(2)
        findBall()
    end)
    Workspace.DescendantAdded:Connect(function(obj)
        if not ballPart then
            if obj:IsA("BasePart") then
                local name = obj.Name:lower()
                if name:find("ball") or name:find("football") then
                    if not obj.Anchored then
                        ballPart = obj
                    end
                end
            end
        end
    end)
    Workspace.DescendantRemoving:Connect(function(obj)
        if obj == ballPart then
            ballPart = nil
            task.wait(0.5)
            findBall()
        end
    end)

    -- Helper Functions
    local function getRoot()
        local character = LocalPlayer.Character
        if character then
            return character:FindFirstChild("HumanoidRootPart")
        end
        return nil
    end
    local function getHumanoid()
        local character = LocalPlayer.Character
        if character then
            return character:FindFirstChildOfClass("Humanoid")
        end
        return nil
    end

    -- Main Tab
    local MainTab = Window:CreateTab("Main", "home")
    local MainSection = MainTab:CreateSection("Main Features")
    MainTab:CreateParagraph({
        Title = "Welcome to VOIDWARE v11.5!",
        Content = "This is a premium script hub with powerful features. Explore all tabs to find what you need!"
    })

    -- Pull Vector Toggle
    local PullToggle = MainTab:CreateToggle({
        Name = "Enable Pull Vector (Hold M1)",
        CurrentValue = false,
        Flag = "PullEnabled",
        Callback = function(Value)
            cfg.pullEnabled = Value
            if Value then
                Rayfield:Notify({
                    Title = "Pull Vector",
                    Content = "Pull Vector enabled! Hold M1 to pull to ball.",
                    Duration = 3,
                    Image = "zap"
                })
            end
        end,
    })

    -- Pull Distance Slider
    MainTab:CreateSlider({
        Name = "Pull Distance",
        Range = {10, 200},
        Increment = 5,
        Suffix = " studs",
        CurrentValue = 50,
        Flag = "PullDistance",
        Callback = function(Value)
            cfg.pullDistance = Value
        end,
    })

    -- Offset Distance Slider
    MainTab:CreateSlider({
        Name = "Offset Distance",
        Range = {1, 10},
        Increment = 0.5,
        Suffix = " studs",
        CurrentValue = 3,
        Flag = "OffsetDistance",
        Callback = function(Value)
            cfg.offsetDistance = Value
        end,
    })

    -- Pull Speed Slider
    MainTab:CreateSlider({
        Name = "Pull Speed",
        Range = {20, 300},
        Increment = 10,
        Suffix = " speed",
        CurrentValue = 100,
        Flag = "PullSpeed",
        Callback = function(Value)
            cfg.pullSpeed = Value
        end,
    })

    -- QB Aimbot Section
    local QBAimbotSection = MainTab:CreateSection("QB Passing Assist")
    MainTab:CreateToggle({
        Name = "Enable QB Pass Assist",
        CurrentValue = false,
        Flag = "QBAimbotEnabled",
        Callback = function(Value)
            cfg.qbAimbotEnabled = Value
            if Value then
                Rayfield:Notify({
                    Title = "QB Pass Assist",
                    Content = "QB Pass Assist enabled! Look at receivers to see indicators.",
                    Duration = 3,
                    Image = "crosshair"
                })
            end
        end,
    })
    MainTab:CreateSlider({
        Name = "Lead Prediction",
        Range = {0.05, 0.5},
        Increment = 0.01,
        Suffix = "s",
        CurrentValue = 0.13,
        Flag = "QBPrediction",
        Callback = function(Value)
            cfg.qbPredictionTime = Value
        end,
    })
    MainTab:CreateSlider({
        Name = "Max Pass Distance",
        Range = {50, 300},
        Increment = 10,
        Suffix = " studs",
        CurrentValue = 150,
        Flag = "QBMaxDistance",
        Callback = function(Value)
            cfg.qbMaxDistance = Value
        end,
    })
    MainTab:CreateToggle({
        Name = "Show Receiver ESP",
        CurrentValue = true,
        Flag = "ShowESP",
        Callback = function(Value)
            cfg.qbShowESP = Value
        end,
    })
    MainTab:CreateToggle({
        Name = "Auto Throw to Target",
        CurrentValue = false,
        Flag = "AutoThrow",
        Callback = function(Value)
            cfg.qbAutoThrow = Value
        end,
    })
    MainTab:CreateToggle({
        Name = "Team Check (Same Team Only)",
        CurrentValue = true,
        Flag = "TeamCheck",
        Callback = function(Value)
            cfg.qbTeamCheck = Value
        end,
    })

    -- Player Tab
    local PlayerTab = Window:CreateTab("Player", "user")
    local MovementSection = PlayerTab:CreateSection("Movement")
    -- Walkspeed
    PlayerTab:CreateSlider({
        Name = "Walkspeed Multiplier",
        Range = {0.5, 5},
        Increment = 0.1,
        Suffix = "x",
        CurrentValue = 1,
        Flag = "WalkspeedMultiplier",
        Callback = function(Value)
            cfg.walkspeedMultiplier = Value
        end,
    })
    -- Fly Toggle
    PlayerTab:CreateToggle({
        Name = "Enable Fly",
        CurrentValue = false,
        Flag = "FlyEnabled",
        Callback = function(Value)
            cfg.flyEnabled = Value
            if Value then
                Rayfield:Notify({
                    Title = "Fly",
                    Content = "Fly enabled! Use WASD + Space/Ctrl to fly.",
                    Duration = 3,
                    Image = "wind"
                })
            else
                Rayfield:Notify({
                    Title = "Fly",
                    Content = "Fly disabled.",
                    Duration = 2,
                    Image = "wind"
                })
            end
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Fly Speed",
        Range = {10, 200},
        Increment = 5,
        Suffix = " speed",
        CurrentValue = 50,
        Flag = "FlySpeed",
        Callback = function(Value)
            cfg.flySpeed = Value
        end,
    })
    -- Jump Power Section
    local JumpSection = PlayerTab:CreateSection("Jumping")
    PlayerTab:CreateToggle({
        Name = "Jump Power Enabled",
        CurrentValue = false,
        Flag = "JumpPowerEnabled",
        Callback = function(Value)
            cfg.jumpPowerEnabled = Value
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Jump Power",
        Range = {0, 100},
        Increment = 1,
        Suffix = "",
        CurrentValue = 0,
        Flag = "JumpPower",
        Callback = function(Value)
            cfg.jumpPower = Value
        end,
    })
    -- Stamina Section
    local StaminaSection = PlayerTab:CreateSection("Stamina")
    PlayerTab:CreateToggle({
        Name = "Infinite Stamina",
        CurrentValue = false,
        Flag = "InfiniteStamina",
        Callback = function(Value)
            cfg.infiniteStamina = Value
        end,
    })
    -- Hitbox Section
    local HitboxSection = PlayerTab:CreateSection("Hitbox")
    PlayerTab:CreateToggle({
        Name = "Bighead Enabled",
        CurrentValue = false,
        Flag = "BigheadEnabled",
        Callback = function(Value)
            cfg.bigheadEnabled = Value
           
            if cfg.bigheadEnabled then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                        local head = player.Character.Head
                        head.CanCollide = cfg.bigheadCanCollide
                        head.Transparency = cfg.bigheadTransparency
                        head.Size = Vector3.new(cfg.bigheadSize, cfg.bigheadSize, cfg.bigheadSize)
                    end
                end
            else
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                        local head = player.Character.Head
                        head.CanCollide = true
                        head.Transparency = 0
                        head.Size = Vector3.new(1, 1, 1)
                    end
                end
            end
        end,
    })
    PlayerTab:CreateToggle({
        Name = "Bighead Collisions",
        CurrentValue = false,
        Flag = "BigheadCollisions",
        Callback = function(Value)
            cfg.bigheadCanCollide = Value
           
            if cfg.bigheadEnabled then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                        player.Character.Head.CanCollide = cfg.bigheadCanCollide
                    end
                end
            end
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Bighead Size",
        Range = {1, 5},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = 1,
        Flag = "BigheadSize",
        Callback = function(Value)
            cfg.bigheadSize = Value
           
            if cfg.bigheadEnabled then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                        player.Character.Head.Size = Vector3.new(cfg.bigheadSize, cfg.bigheadSize, cfg.bigheadSize)
                    end
                end
            end
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Bighead Transparency",
        Range = {0, 1},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = 0,
        Flag = "BigheadTransparency",
        Callback = function(Value)
            cfg.bigheadTransparency = Value
           
            if cfg.bigheadEnabled then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                        player.Character.Head.Transparency = cfg.bigheadTransparency
                    end
                end
            end
        end,
    })
    -- Tackle Reach Section
    local TackleSection = PlayerTab:CreateSection("Tackle Reach")
    PlayerTab:CreateToggle({
        Name = "Tackle Reach Enabled",
        CurrentValue = false,
        Flag = "TackleReachEnabled",
        Callback = function(Value)
            cfg.tackleReachEnabled = Value
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Tackle Reach Distance",
        Range = {1, 15},
        Increment = 0.1,
        Suffix = " studs",
        CurrentValue = 1,
        Flag = "TackleReachDistance",
        Callback = function(Value)
            cfg.tackleReachDistance = Value
        end,
    })
    -- Auto Follow Section
    local FollowSection = PlayerTab:CreateSection("Auto Follow Ball Carrier")
    PlayerTab:CreateToggle({
        Name = "Auto Follow Ball Carrier",
        CurrentValue = false,
        Flag = "AutoFollowBallCarrier",
        Callback = function(Value)
            cfg.autoFollowBallCarrier = Value
            if Value then
                Rayfield:Notify({
                    Title = "Auto Follow",
                    Content = "Auto follow enabled! Following ball carrier.",
                    Duration = 3,
                    Image = "navigation"
                })
            end
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Follow Distance",
        Range = {3, 20},
        Increment = 0.5,
        Suffix = " studs",
        CurrentValue = 5,
        Flag = "FollowDistance",
        Callback = function(Value)
            cfg.followDistance = Value
        end,
    })
    PlayerTab:CreateSlider({
        Name = "Follow Speed",
        Range = {50, 300},
        Increment = 10,
        Suffix = " speed",
        CurrentValue = 150,
        Flag = "FollowSpeed",
        Callback = function(Value)
            cfg.followSpeed = Value
        end,
    })

    -- Teleport Tab
    local TeleportTab = Window:CreateTab("Teleport", "map-pin")
    local TeleportSection = TeleportTab:CreateSection("Ball Teleport")
    -- Ball Teleport Keybind
    TeleportTab:CreateKeybind({
        Name = "Teleport to Ball Key",
        CurrentKeybind = "B",
        HoldToInteract = false,
        Flag = "BallTeleportKey",
        Callback = function(Keybind)
            local success, keyCode = pcall(function()
                return Enum.KeyCode[Keybind]
            end)
            if success then
                cfg.ballTeleportKey = keyCode
            end
        end,
    })
    -- Teleport to Ball Button
    TeleportTab:CreateButton({
        Name = "Teleport to Ball Now",
        Callback = function()
            local hrp = getRoot()
            if not hrp then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Could not find your character!",
                    Duration = 3,
                    Image = "alert-circle"
                })
                return
            end
           
            if not ballPart then
                findBall()
            end
           
            if ballPart and ballPart.Parent then
                hrp.CFrame = CFrame.new(ballPart.Position + Vector3.new(0, 3, 0))
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "Teleported to ball!",
                    Duration = 2,
                    Image = "map-pin"
                })
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Ball not found!",
                    Duration = 3,
                    Image = "alert-circle"
                })
            end
        end,
    })

    -- Misc Tab
    local MiscTab = Window:CreateTab("Misc", "package")
    local MiscSection = MiscTab:CreateSection("Miscellaneous")
    -- Quick TP
    MiscTab:CreateKeybind({
        Name = "Quick TP Forward",
        CurrentKeybind = "F",
        HoldToInteract = false,
        Flag = "QuickTP",
        Callback = function(Keybind)
            local hrp = getRoot()
            if hrp then
                hrp.CFrame = hrp.CFrame * CFrame.new(0, 0, -2)
            end
        end,
    })
    -- Infinite Dive
    MiscTab:CreateToggle({
        Name = "Infinite Dive",
        CurrentValue = false,
        Flag = "InfiniteDive",
        Callback = function(Value)
            spawn(function()
                while Value do
                    task.wait(0.1)
                    pcall(function()
                        local mechMod = require(ReplicatedStorage.Assets.Modules.Client.Mechanics)
                        mechMod.PlayerDiving = false
                        mechMod.PlayerCanDive = true
                    end)
                end
            end)
        end,
    })
    -- Spin Moves Section
    local SpinSection = MiscTab:CreateSection("Spin Moves")
    MiscTab:CreateKeybind({
        Name = "Spin Left",
        CurrentKeybind = "R",
        HoldToInteract = false,
        Flag = "SpinLeft",
        Callback = function(Keybind)
            local char = LocalPlayer.Character
            if not char then return end
           
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum then return end
           
            local animFolder = ReplicatedStorage:FindFirstChild("Assets")
            if animFolder then
                animFolder = animFolder:FindFirstChild("Storage")
                if animFolder then
                    animFolder = animFolder:FindFirstChild("Animations")
                    if animFolder then
                        local spinAnim = animFolder:FindFirstChild("UF_SpinMoveLeft")
                        if spinAnim then
                            local anim = hum:LoadAnimation(spinAnim)
                            local speed = 1.5
                            local offset = CFrame.new(-13, 0, -6)
                           
                            if not anim.IsPlaying and hum:GetState() ~= Enum.HumanoidStateType.FallingDown and not hum.PlatformStand then
                                local duration = anim.Length / speed
                                local velocity = ((hrp.CFrame * offset).Position - hrp.CFrame.Position) / duration
                               
                                local attachment = Instance.new("Attachment", hrp)
                                attachment.WorldPosition = hrp.AssemblyCenterOfMass
                               
                                hum.AutoRotate = false
                               
                                local linearVel = Instance.new("LinearVelocity", hrp)
                                linearVel.Attachment0 = attachment
                                linearVel.MaxForce = 10000
                                linearVel.VelocityConstraintMode = Enum.VelocityConstraintMode.Plane
                                linearVel.PrimaryTangentAxis = Vector3.new(1, 0, 0)
                                linearVel.SecondaryTangentAxis = Vector3.new(0, 0, 1)
                                linearVel.RelativeTo = Enum.ActuatorRelativeTo.World
                                linearVel.PlaneVelocity = Vector2.new(math.floor(velocity.X + 0.5), math.floor(velocity.Z + 0.5))
                               
                                anim:Play(nil, nil, speed)
                               
                                task.delay(duration, function()
                                    hum.AutoRotate = true
                                    linearVel:Destroy()
                                    attachment:Destroy()
                                end)
                            end
                        end
                    end
                end
            end
        end,
    })
    MiscTab:CreateKeybind({
        Name = "Spin Right",
        CurrentKeybind = "T",
        HoldToInteract = false,
        Flag = "SpinRight",
        Callback = function(Keybind)
            local char = LocalPlayer.Character
            if not char then return end
           
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum then return end
           
            local animFolder = ReplicatedStorage:FindFirstChild("Assets")
            if animFolder then
                animFolder = animFolder:FindFirstChild("Storage")
                if animFolder then
                    animFolder = animFolder:FindFirstChild("Animations")
                    if animFolder then
                        local spinAnim = animFolder:FindFirstChild("UF_SpinMoveLeft")
                        if spinAnim then
                            local anim = hum:LoadAnimation(spinAnim)
                            local speed = 1.5
                            local offset = CFrame.new(13, 0, -6)
                           
                            if not anim.IsPlaying and hum:GetState() ~= Enum.HumanoidStateType.FallingDown and not hum.PlatformStand then
                                local duration = anim.Length / speed
                                local velocity = ((hrp.CFrame * offset).Position - hrp.CFrame.Position) / duration
                               
                                local attachment = Instance.new("Attachment", hrp)
                                attachment.WorldPosition = hrp.AssemblyCenterOfMass
                               
                                hum.AutoRotate = false
                               
                                local linearVel = Instance.new("LinearVelocity", hrp)
                                linearVel.Attachment0 = attachment
                                linearVel.MaxForce = 10000
                                linearVel.VelocityConstraintMode = Enum.VelocityConstraintMode.Plane
                                linearVel.PrimaryTangentAxis = Vector3.new(1, 0, 0)
                                linearVel.SecondaryTangentAxis = Vector3.new(0, 0, 1)
                                linearVel.RelativeTo = Enum.ActuatorRelativeTo.World
                                linearVel.PlaneVelocity = Vector2.new(math.floor(velocity.X + 0.5), math.floor(velocity.Z + 0.5))
                               
                                anim:Play(nil, nil, speed)
                               
                                task.delay(duration, function()
                                    hum.AutoRotate = true
                                    linearVel:Destroy()
                                    attachment:Destroy()
                                end)
                            end
                        end
                    end
                end
            end
        end,
    })

    -- Anti-AFK
    local UtilitySection = MiscTab:CreateSection("Utility")
    MiscTab:CreateButton({
        Name = "Anti-AFK",
        Callback = function()
            if getconnections then
                for _, connection in pairs(getconnections(LocalPlayer.Idled)) do
                    connection:Disable()
                end
                Rayfield:Notify({
                    Title = "Anti-AFK",
                    Content = "Anti-AFK enabled!",
                    Duration = 3,
                    Image = "check-circle"
                })
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Executor doesn't support getconnections",
                    Duration = 3,
                    Image = "alert-circle"
                })
            end
        end,
    })

    -- Mobile Tab
    local MobileTab = Window:CreateTab("Mobile", "smartphone")
    local MobileSection = MobileTab:CreateSection("Mobile Controls")
    MobileTab:CreateParagraph({
        Title = "Mobile Support",
        Content = "This tab provides on-screen buttons for mobile players. Drag the control panel anywhere on screen!"
    })
    -- Create Mobile GUI
    local function createMobileGUI()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "VOIDWAREMobile"
        ScreenGui.ResetOnSpawn = false
        ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
       
        if LocalPlayer.PlayerGui:FindFirstChild("VOIDWAREMobile") then
            LocalPlayer.PlayerGui.VOIDWAREMobile:Destroy()
        end
       
        ScreenGui.Parent = LocalPlayer.PlayerGui
       
        local MainFrame = Instance.new("Frame")
        MainFrame.Name = "MainFrame"
        MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        MainFrame.BorderSizePixel = 0
        MainFrame.Position = UDim2.new(0.85, 0, 0.3, 0)
        MainFrame.Size = UDim2.new(0, 140, 0, 280)
        MainFrame.Parent = ScreenGui
       
        local Corner = Instance.new("UICorner")
        Corner.CornerRadius = UDim.new(0, 12)
        Corner.Parent = MainFrame
       
        local Stroke = Instance.new("UIStroke")
        Stroke.Color = Color3.fromRGB(138, 43, 226)
        Stroke.Thickness = 2
        Stroke.Parent = MainFrame
       
        local TitleBar = Instance.new("Frame")
        TitleBar.Name = "TitleBar"
        TitleBar.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
        TitleBar.BorderSizePixel = 0
        TitleBar.Size = UDim2.new(1, 0, 0, 35)
        TitleBar.Parent = MainFrame
       
        local TitleCorner = Instance.new("UICorner")
        TitleCorner.CornerRadius = UDim.new(0, 12)
        TitleCorner.Parent = TitleBar
       
        local Title = Instance.new("TextLabel")
        Title.Name = "Title"
        Title.BackgroundTransparency = 1
        Title.Size = UDim2.new(0.7, 0, 1, 0)
        Title.Font = Enum.Font.GothamBold
        Title.Text = "VOIDWARE"
        Title.TextColor3 = Color3.fromRGB(255, 255, 255)
        Title.TextSize = 16
        Title.TextXAlignment = Enum.TextXAlignment.Left
        Title.Position = UDim2.new(0, 10, 0, 0)
        Title.Parent = TitleBar
       
        local CloseButton = Instance.new("TextButton")
        CloseButton.Name = "CloseButton"
        CloseButton.BackgroundTransparency = 1
        CloseButton.Position = UDim2.new(0.7, 0, 0, 0)
        CloseButton.Size = UDim2.new(0.3, 0, 1, 0)
        CloseButton.Font = Enum.Font.GothamBold
        CloseButton.Text = "X"
        CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        CloseButton.TextSize = 18
        CloseButton.Parent = TitleBar
       
        CloseButton.MouseButton1Click:Connect(function()
            ScreenGui:Destroy()
        end)
       
        local ButtonContainer = Instance.new("Frame")
        ButtonContainer.Name = "ButtonContainer"
        ButtonContainer.BackgroundTransparency = 1
        ButtonContainer.Position = UDim2.new(0, 10, 0, 45)
        ButtonContainer.Size = UDim2.new(1, -20, 1, -55)
        ButtonContainer.Parent = MainFrame
       
        local function createButton(name, position, callback)
            local Button = Instance.new("TextButton")
            Button.Name = name
            Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
            Button.Position = position
            Button.Size = UDim2.new(1, 0, 0, 45)
            Button.Font = Enum.Font.GothamBold
            Button.Text = name
            Button.TextColor3 = Color3.fromRGB(255, 255, 255)
            Button.TextSize = 14
            Button.AutoButtonColor = false
            Button.Parent = ButtonContainer
           
            local ButtonCorner = Instance.new("UICorner")
            ButtonCorner.CornerRadius = UDim.new(0, 8)
            ButtonCorner.Parent = Button
           
            local ButtonStroke = Instance.new("UIStroke")
            ButtonStroke.Color = Color3.fromRGB(138, 43, 226)
            ButtonStroke.Thickness = 1
            ButtonStroke.Parent = Button
            Button.MouseButton1Click:Connect(callback)
           
            Button.MouseEnter:Connect(function()
                Button.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
            end)
           
            Button.MouseLeave:Connect(function()
                if Button.Name ~= "PULL" then
                    Button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                end
            end)
           
            return Button
        end
        local pullButton = createButton("PULL", UDim2.new(0, 0, 0, 0), function() end)
        pullButton.MouseButton1Down:Connect(function()
            if cfg.pullEnabled then
                pulling = true
                pullButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
            end
        end)
        pullButton.MouseButton1Up:Connect(function()
            pulling = false
            pullButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        end)
        createButton("THROW", UDim2.new(0, 0, 0, 55), function()
            local char = LocalPlayer.Character
            if char then
                pcall(function()
                    local args = {
                        [1] = "Throw",
                        [2] = Camera.CFrame.Position + Camera.CFrame.LookVector * 100,
                        [3] = 1
                    }
                    ReplicatedStorage.Remotes.CharacterSystems:FireServer(unpack(args))
                end)
            end
        end)
        createButton("TP BALL", UDim2.new(0, 0, 0, 110), function()
            local hrp = getRoot()
            if hrp and ballPart and ballPart.Parent then
                hrp.CFrame = CFrame.new(ballPart.Position + Vector3.new(0, 3, 0))
            end
        end)
        local dragging = false
        local dragInput
        local dragStart
        local startPos
        local function update(input)
            local delta = input.Position - dragStart
            MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
        TitleBar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = MainFrame.Position
               
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        TitleBar.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                dragInput = input
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if input == dragInput and dragging then
                update(input)
            end
        end)
        return ScreenGui
    end
    local mobileGUI = nil
    MobileTab:CreateToggle({
        Name = "Enable Mobile Controls",
        CurrentValue = true,
        Flag = "MobileControls",
        Callback = function(Value)
            if Value then
                mobileGUI = createMobileGUI()
                Rayfield:Notify({
                    Title = "Mobile Controls",
                    Content = "Mobile controls enabled!",
                    Duration = 4,
                    Image = "smartphone"
                })
            else
                if mobileGUI then
                    mobileGUI:Destroy()
                    mobileGUI = nil
                end
            end
        end,
    })
    task.wait(1)
    mobileGUI = createMobileGUI()
    MobileTab:CreateButton({
        Name = "Reset Mobile Panel Position",
        Callback = function()
            if mobileGUI then
                mobileGUI:Destroy()
                task.wait(0.1)
                mobileGUI = createMobileGUI()
            end
        end,
    })
    MobileTab:CreateParagraph({
        Title = "Button Guide",
        Content = "PULL: Hold to pull to ball\nTHROW: Tap to throw football\nTP BALL: Teleport to ball\nX: Close mobile panel"
    })

    -- Settings Tab
    local SettingsTab = Window:CreateTab("Settings", "settings")
    local UISection = SettingsTab:CreateSection("UI Settings")
    SettingsTab:CreateLabel("VOIDWARE v11.5 Version 1.0")
    local ThemeDropdown = SettingsTab:CreateDropdown({
        Name = "Theme",
        Options = {"Default", "Amethyst", "DarkBlue", "Green", "Ocean", "Bloom"},
        CurrentOption = {"Dark"},
        MultipleOptions = false,
        Flag = "Theme",
        Callback = function(Option)
            Window:ModifyTheme(Option[1])
        end,
    })
    SettingsTab:CreateKeybind({
        Name = "Toggle UI Key",
        CurrentKeybind = "K",
        HoldToInteract = false,
        Flag = "UIToggle",
        Callback = function(Keybind)
            print("UI Toggle Key:", Keybind)
        end,
    })
    local SettingsSection = SettingsTab:CreateSection("Script Settings")
    SettingsTab:CreateButton({
        Name = "Copy Discord Invite",
        Callback = function()
            setclipboard("https://discord.gg/CaBXG2jms3")
            Rayfield:Notify({
                Title = "Copied",
                Content = "Discord invite copied to clipboard!",
                Duration = 3,
                Image = "clipboard"
            })
        end,
    })
    SettingsTab:CreateButton({
        Name = "Rejoin Server",
        Callback = function()
            game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
        end,
    })
    SettingsTab:CreateButton({
        Name = "Destroy UI",
        Callback = function()
            Rayfield:Destroy()
        end,
    })

    -- ========== LOGIC IMPLEMENTATION ==========
    Workspace.ChildAdded:Connect(function(player)
        if cfg.bigheadEnabled and player:FindFirstChild("Head") then
            task.wait()
            local head = player.Head
            head.CanCollide = cfg.bigheadCanCollide
            head.Transparency = cfg.bigheadTransparency
            head.Size = Vector3.new(cfg.bigheadSize, cfg.bigheadSize, cfg.bigheadSize)
        end
    end)
    spawn(function()
        while true do
            RunService.Heartbeat:Wait()
            if cfg.infiniteStamina then
                pcall(function()
                    local mechMod = require(ReplicatedStorage.Assets.Modules.Client.Mechanics)
                    mechMod.Stamina = 100
                end)
            end
        end
    end)
    spawn(function()
        while true do
            RunService.Heartbeat:Wait()
            local humanoid = getHumanoid()
            if humanoid then
                local baseSpeed = cfg.walkspeedBase or 16
                local multiplier = cfg.walkspeedMultiplier or 1
                humanoid.WalkSpeed = baseSpeed * multiplier
            end
        end
    end)
    RunService.Heartbeat:Connect(function(dt)
        if not cfg.pullEnabled then return end
        if not pulling then return end
        local hrp = getRoot()
        if not hrp then return end
        if not ballPart then
            findBall()
            if not ballPart then return end
        end
        if not ballPart.Parent then
            ballPart = nil
            return
        end
        local ballPos = ballPart.Position
        local playerPos = hrp.Position
        local distance = (ballPos - playerPos).Magnitude
        if distance > cfg.pullDistance then return end
        if distance <= cfg.offsetDistance then return end
        local direction = (ballPos - playerPos).Unit
        local maxMove = cfg.pullSpeed * dt
        local moveAmount = math.min(maxMove, distance - cfg.offsetDistance)
        hrp.CFrame = hrp.CFrame + (direction * moveAmount)
    end)
    -- ========== NEW QB PASS ASSIST SYSTEM (LIKE TIKTOK VIDEO) ==========
    -- ESP Drawing Objects Storage
    local espObjects = {}
    -- Create ESP GUI
    local function createESPGui()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "QBPassAssistESP"
        ScreenGui.ResetOnSpawn = false
        ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        ScreenGui.Parent = LocalPlayer.PlayerGui
        return ScreenGui
    end
    local espGui = createESPGui()
    -- Function to create ESP for a player
    local function createPlayerESP(player)
        if espObjects[player] then
            return espObjects[player]
        end
        local espData = {}
        -- Box
        espData.Box = Drawing.new("Square")
        espData.Box.Thickness = 2
        espData.Box.Filled = false
        espData.Box.Transparency = 1
        espData.Box.Visible = false
        espData.Box.Color = Color3.fromRGB(0, 255, 0)
        -- Name Label
        espData.NameLabel = Drawing.new("Text")
        espData.NameLabel.Size = 16
        espData.NameLabel.Center = true
        espData.NameLabel.Outline = true
        espData.NameLabel.Color = Color3.fromRGB(255, 255, 255)
        espData.NameLabel.Visible = false
        espData.NameLabel.Text = player.Name
        -- Distance Label
        espData.DistanceLabel = Drawing.new("Text")
        espData.DistanceLabel.Size = 14
        espData.DistanceLabel.Center = true
        espData.DistanceLabel.Outline = true
        espData.DistanceLabel.Color = Color3.fromRGB(255, 255, 255)
        espData.DistanceLabel.Visible = false
        -- Lead Indicator (circle)
        espData.LeadIndicator = Drawing.new("Circle")
        espData.LeadIndicator.Thickness = 2
        espData.LeadIndicator.NumSides = 20
        espData.LeadIndicator.Radius = 8
        espData.LeadIndicator.Filled = true
        espData.LeadIndicator.Transparency = 0.7
        espData.LeadIndicator.Color = Color3.fromRGB(255, 165, 0)
        espData.LeadIndicator.Visible = false
        espObjects[player] = espData
        return espData
    end
    -- Function to remove ESP for a player
    local function removePlayerESP(player)
        if espObjects[player] then
            for _, obj in pairs(espObjects[player]) do
                obj:Remove()
            end
            espObjects[player] = nil
        end
    end
    -- Clean up on player leave
    Players.PlayerRemoving:Connect(function(player)
        removePlayerESP(player)
    end)
    -- Function to check if player has ball
    local function playerHasBall(player)
        if player.Character then
            for _, obj in pairs(player.Character:GetDescendants()) do
                if obj.Name:lower():find("football") or obj.Name:lower():find("ball") then
                    return true
                end
            end
        end
        return false
    end
    -- Function to get receivers (teammates without ball)
    local function getReceivers()
        local receivers = {}
        local myRoot = getRoot()
        if not myRoot then return receivers end
        -- Check if I have the ball
        local iHaveBall = playerHasBall(LocalPlayer)
        if not iHaveBall then return receivers end
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                -- Team check
                if cfg.qbTeamCheck and player.Team ~= LocalPlayer.Team then
                    continue
                end
               
                local targetHRP = player.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
               
                if targetHRP and humanoid and humanoid.Health > 0 then
                    -- Don't target players with the ball
                    if not playerHasBall(player) then
                        local distance = (targetHRP.Position - myRoot.Position).Magnitude
                       
                        if distance <= cfg.qbMaxDistance then
                            table.insert(receivers, {
                                Player = player,
                                HRP = targetHRP,
                                Distance = distance
                            })
                        end
                    end
                end
            end
        end
        return receivers
    end
    -- Function to find best receiver (closest to camera center)
    local function findBestReceiver(receivers)
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local bestReceiver = nil
        local bestDist = math.huge
        for _, receiverData in pairs(receivers) do
            local screenPos, onScreen = Camera:WorldToViewportPoint(receiverData.HRP.Position)
            if onScreen then
                local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                if screenDist < bestDist then
                    bestDist = screenDist
                    bestReceiver = receiverData
                end
            end
        end
        return bestReceiver
    end
    -- Main QB Pass Assist Loop
    RunService.RenderStepped:Connect(function()
        if not cfg.qbAimbotEnabled then
            -- Hide all ESP
            for _, espData in pairs(espObjects) do
                espData.Box.Visible = false
                espData.NameLabel.Visible = false
                espData.DistanceLabel.Visible = false
                espData.LeadIndicator.Visible = false
            end
            return
        end
        local receivers = getReceivers()
        -- Update ESP for all receivers
        for _, receiverData in pairs(receivers) do
            local player = receiverData.Player
            local hrp = receiverData.HRP
           
            local espData = createPlayerESP(player)
           
            if cfg.qbShowESP then
                -- Calculate predicted position
                local velocity = hrp.AssemblyLinearVelocity
                local predictedPos = hrp.Position + (velocity * cfg.qbPredictionTime)
               
                -- Get screen positions
                local hrpScreen, hrpOnScreen = Camera:WorldToViewportPoint(hrp.Position)
                local headPos = hrp.Position + Vector3.new(0, 2, 0)
                local footPos = hrp.Position - Vector3.new(0, 3, 0)
                local headScreen = Camera:WorldToViewportPoint(headPos)
                local footScreen = Camera:WorldToViewportPoint(footPos)
               
                if hrpOnScreen then
                    -- Draw box
                    local height = math.abs(headScreen.Y - footScreen.Y)
                    local width = height * 0.5
                   
                    espData.Box.Size = Vector2.new(width, height)
                    espData.Box.Position = Vector2.new(hrpScreen.X - width/2, headScreen.Y)
                    espData.Box.Visible = true
                   
                    -- Name label
                    espData.NameLabel.Position = Vector2.new(hrpScreen.X, headScreen.Y - 20)
                    espData.NameLabel.Text = player.Name
                    espData.NameLabel.Visible = true
                   
                    -- Distance label
                    espData.DistanceLabel.Position = Vector2.new(hrpScreen.X, footScreen.Y + 5)
                    espData.DistanceLabel.Text = string.format("%.0f studs", receiverData.Distance)
                    espData.DistanceLabel.Visible = true
                   
                    -- Lead indicator (predicted position)
                    local predictedScreen, predictedOnScreen = Camera:WorldToViewportPoint(predictedPos)
                    if predictedOnScreen then
                        espData.LeadIndicator.Position = Vector2.new(predictedScreen.X, predictedScreen.Y)
                        espData.LeadIndicator.Visible = true
                    else
                        espData.LeadIndicator.Visible = false
                    end
                else
                    espData.Box.Visible = false
                    espData.NameLabel.Visible = false
                    espData.DistanceLabel.Visible = false
                    espData.LeadIndicator.Visible = false
                end
            else
                espData.Box.Visible = false
                espData.NameLabel.Visible = false
                espData.DistanceLabel.Visible = false
                espData.LeadIndicator.Visible = false
            end
        end
        -- Find and highlight best receiver
        local bestReceiver = findBestReceiver(receivers)
        if bestReceiver then
            local espData = espObjects[bestReceiver.Player]
            if espData and cfg.qbShowESP then
                -- Highlight target with different color
                espData.Box.Color = Color3.fromRGB(255, 0, 0)
                espData.NameLabel.Color = Color3.fromRGB(255, 0, 0)
               
                -- Auto throw if enabled
                if cfg.qbAutoThrow then
                    local velocity = bestReceiver.HRP.AssemblyLinearVelocity
                    local throwTarget = bestReceiver.HRP.Position + (velocity * cfg.qbPredictionTime)
                   
                    pcall(function()
                        local args = {
                            [1] = "Throw",
                            [2] = throwTarget,
                            [3] = 1
                        }
                        ReplicatedStorage.Remotes.CharacterSystems:FireServer(unpack(args))
                    end)
                end
            end
        end
        -- Reset colors for non-targeted receivers
        for player, espData in pairs(espObjects) do
            if not bestReceiver or player ~= bestReceiver.Player then
                espData.Box.Color = Color3.fromRGB(0, 255, 0)
                espData.NameLabel.Color = Color3.fromRGB(255, 255, 255)
            end
        end
    end)

    -- Fly Logic
    local flying = false
    local flyBodyVelocity = nil
    local flyBodyGyro = nil
    local function startFly()
        local root = getRoot()
        local humanoid = getHumanoid()
        if not root or not humanoid then return end
        if flying then return end
        flying = true
        flyBodyVelocity = Instance.new("BodyVelocity")
        flyBodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        flyBodyVelocity.P = 1e4
        flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
        flyBodyVelocity.Parent = root
        flyBodyGyro = Instance.new("BodyGyro")
        flyBodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
        flyBodyGyro.P = 1e4
        flyBodyGyro.CFrame = root.CFrame
        flyBodyGyro.Parent = root
    end
    local function stopFly()
        if flying then
            flying = false
            if flyBodyVelocity then
                flyBodyVelocity:Destroy()
                flyBodyVelocity = nil
            end
            if flyBodyGyro then
                flyBodyGyro:Destroy()
                flyBodyGyro = nil
            end
        end
    end
    RunService.Heartbeat:Connect(function()
        if cfg.flyEnabled then
            if not flying then
                startFly()
            end
            local root = getRoot()
            if root and flyBodyVelocity and flyBodyGyro then
                local moveDir = Vector3.new()
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveDir = moveDir + Camera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveDir = moveDir - Camera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveDir = moveDir - Camera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveDir = moveDir + Camera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    moveDir = moveDir + Vector3.new(0, 1, 0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    moveDir = moveDir - Vector3.new(0, 1, 0)
                end
                if moveDir.Magnitude > 0 then
                    moveDir = moveDir.Unit * cfg.flySpeed
                end
                flyBodyVelocity.Velocity = moveDir
                flyBodyGyro.CFrame = Camera.CFrame
            end
        else
            if flying then
                stopFly()
            end
        end
    end)

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == cfg.ballTeleportKey then
            local hrp = getRoot()
            if not hrp then return end
            if not ballPart then
                findBall()
            end
           
            if ballPart and ballPart.Parent then
                hrp.CFrame = CFrame.new(ballPart.Position + Vector3.new(0, 3, 0))
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "Teleported to ball!",
                    Duration = 2,
                    Image = "map-pin"
                })
            end
        end
    end)

    spawn(function()
        while task.wait() do
            local hrp = getRoot()
            local humanoid = getHumanoid()
            if cfg.jumpPowerEnabled and hrp and humanoid then
                humanoid.UseJumpPower = true
                humanoid.JumpPower = 50 + (cfg.jumpPower * 2)
            elseif humanoid then
                humanoid.JumpPower = 50
            end
        end
    end)

    local function getBallCarrier()
        if not ballPart or not ballPart.Parent then
            return nil
        end
        local closestPlayer = nil
        local closestDistance = math.huge
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
                if hrp and humanoid and humanoid.Health > 0 then
                    local dist = (hrp.Position - ballPart.Position).Magnitude
                    if dist < 10 and dist < closestDistance then
                        closestDistance = dist
                        closestPlayer = plr
                    end
                end
            end
        end
        return closestPlayer
    end
    RunService.Heartbeat:Connect(function(dt)
        if not cfg.autoFollowBallCarrier then return end
        local hrp = getRoot()
        if not hrp then return end
        local carrier = getBallCarrier()
        if not carrier or not carrier.Character then return end
        local carrierHRP = carrier.Character:FindFirstChild("HumanoidRootPart")
        if not carrierHRP then return end
        local distance = (carrierHRP.Position - hrp.Position).Magnitude
        if distance > cfg.followDistance then
            local direction = (carrierHRP.Position - hrp.Position).Unit
            local moveAmount = math.min(cfg.followSpeed * dt, distance - cfg.followDistance)
           
            hrp.CFrame = hrp.CFrame + (direction * moveAmount)
        end
    end)
    spawn(function()
        while true do
            task.wait(0.1)
            if cfg.tackleReachEnabled then
                local hrp = getRoot()
                if not hrp then continue end
                for _, targetPlayer in ipairs(Players:GetPlayers()) do
                    if targetPlayer ~= LocalPlayer and targetPlayer.Character then
                        local hasFootballGrip = false
                        for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                            if part.Name == "FootballGrip" then
                                hasFootballGrip = true
                                break
                            end
                        end
                       
                        if hasFootballGrip then
                            local hitbox = nil
                            pcall(function()
                                for _, obj in ipairs(Workspace:GetDescendants()) do
                                    if obj.Name == "Hitboxes" then
                                        hitbox = obj:FindFirstChild(targetPlayer.Name)
                                        if hitbox then break end
                                    end
                                end
                            end)
                           
                            if hitbox and (hitbox.Position - hrp.Position).Magnitude <= cfg.tackleReachDistance then
                                local originalPos = hitbox.Position
                                hitbox.Position = hrp.Position
                                task.wait(0.1)
                                hitbox.Position = originalPos
                            end
                        end
                    end
                end
            end
        end
    end)

    Rayfield:LoadConfiguration()
    print("VOIDWARE v11.5 Loaded Successfully!")
end

-- STARTUP
if KEY_SYSTEM.Enabled then
    local savedKey = LoadSavedKey()
   
    if savedKey then
        print("ðŸ”‘ Found saved key, validating...")
        local valid, message = ValidateKey(savedKey)
       
        if valid then
            print("âœ… Key valid! Loading script...")
            LoadMainScript()
        else
            print("âŒ Saved key invalid: " .. message)
            ShowKeySystem()
        end
    else
        print("ðŸ”‘ No saved key found, showing key system...")
        ShowKeySystem()
    end
else
    LoadMainScript()
end
